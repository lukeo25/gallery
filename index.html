<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Gallery Zero</title>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.css">
<script src="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.js"></script>

<style>
  :root{
    --bg:#0b0d10; --bg2:#12151a; --fg:#e7ecf2; --line:#1e2230; --chip:#1a2333; --chipb:#223148;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  header{padding:10px 14px;background:var(--bg2);border-bottom:1px solid var(--line);display:flex;align-items:center;justify-content:space-between;gap:12px}
  header h1{margin:0;font-size:18px;font-weight:700;letter-spacing:.2px}
  .actions{display:flex;gap:8px;flex-wrap:wrap}
  .btn{appearance:none;border:1px solid var(--chipb);background:var(--chip);color:var(--fg);padding:8px 10px;border-radius:10px;font-size:12px;cursor:pointer}
  .btn:hover{filter:brightness(1.1)}
  #viewer{height:calc(100vh - 56px)}
  #bake{display:none}
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:20px;background:#0f141b;color:#d4ddea;padding:10px 14px;border-radius:10px;font-size:13px;border:1px solid #223148;display:none;z-index:30}
</style>
</head>
<body>
  <header>
    <h1>Gallery Zero</h1>
    <div class="actions">
      <button id="dlColor" class="btn">Download Colour (EQ)</button>
      <button id="dlNormal" class="btn">Download Normal (EQ)</button>
      <button id="dlHeight" class="btn">Download Height (EQ)</button>
      <button id="dlLit" class="btn">Download Lit Pano</button>
    </div>
  </header>

  <div id="viewer"></div>
  <canvas id="bake"></canvas>
  <div id="toast" class="toast"></div>

<script>
/* ===================== CONFIG ===================== */
const GH_USER = "lukeo25";
const GH_REPO = "gallery";
const WALLS_API = `https://api.github.com/repos/${GH_USER}/${GH_REPO}/contents/walls`;

const ROOM = { width: 10.0, depth: 10.0, height: 3.0, eyeY: 1.6 };
const GLOBAL_YAW_DEG = 0;
const SHIFT_Y_M = 0.0;

const OUTPUT = { width: 4096, height: 2048 };   // equirect size
const SUPERSAMPLE = 1.25;
const USE_BILINEAR = true;
const BACKGROUND_RGBA = [255,255,255,255];

/* ===== Lighting: 5 fixtures per wall, aimed to a band height ===== */
const AMBIENT = 0.62;              // bright base fill

// target band height (meters from floor) to light across each wall
const WASH_BAND_Y_M = 1.45;

const DOWNLIGHTS = {
  perWall: 5,
  endMarginM: 0.80,                // keep away from corners
  offWallM: 0.06,                  // fixture sits slightly off the wall (toward room)
  belowCeilingM: 0.03,             // mount just below ceiling
  coneAngleDeg: 48,                // tighter beam to hit the band
  featherDeg: 18,                  // soft edge
  intensity: 3.0,                  // brightness per light
  range: 4.5                        // reach to floor
};

const SPECULAR = 0.10;
const SHININESS = 28.0;

const SHADOWS = false;             // set true for occlusion if desired
const SHADOW_EPS = 1e-3;

/* Bump/Normal helpers (for lit pano; exporters ignore lighting) */
const BUMP_SCALE = 1.5;
const BUMP_EPS = 1.0/1024.0;
/* =================================================== */

const el = q => document.querySelector(q);
function toast(msg,ms=1800){ const t=el('#toast'); t.textContent=msg; t.style.display='block'; clearTimeout(toast._h); toast._h=setTimeout(()=>t.style.display='none',ms); }

/* ---------- math ---------- */
const D2R=Math.PI/180;
function normalize(v){ const L=Math.hypot(v[0],v[1],v[2])||1; return [v[0]/L, v[1]/L, v[2]/L]; }
function dot(a,b){ return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
function add(a,b){ return [a[0]+b[0],a[1]+b[1],a[2]+b[2]]; }
function sub(a,b){ return [a[0]-b[0],a[1]-b[1],a[2]-b[2]]; }
function mul(a,k){ return [a[0]*k,a[1]*k,a[2]*k]; }
function reflect(I,N){ const dn=dot(I,N); return sub(I, mul(N,2*dn)); }
function dirFromYawPitch(yawDeg,pitchDeg){
  const y=yawDeg*D2R, p=pitchDeg*D2R;
  const cp=Math.cos(p), sp=Math.sin(p), cy=Math.cos(y), sy=Math.sin(y);
  return [cp*cy, sp, cp*sy];
}
function rotateY(v, deg){
  const r=deg*D2R, c=Math.cos(r), s=Math.sin(r);
  const x=v[0], z=v[2];
  return [c*x + s*z, v[1], -s*x + c*z];
}

/* ---------- sampling ---------- */
function sampleBilinear(S, sw, sh, u, v){
  const fx = Math.max(0, Math.min(sw-1, u * (sw-1)));
  const fy = Math.max(0, Math.min(sh-1, v * (sh-1)));
  const x0 = Math.floor(fx), y0 = Math.floor(fy);
  const x1 = Math.min(sw-1, x0+1), y1 = Math.min(sh-1, y0+1);
  const dx = fx - x0, dy = fy - y0;
  const i00 = (y0*sw + x0) * 4, i10 = (y0*sw + x1) * 4;
  const i01 = (y1*sw + x0) * 4, i11 = (y1*sw + x1) * 4;
  function lerp(a,b,t){ return a + (b-a)*t; }
  const r0=lerp(S[i00],S[i10],dx), g0=lerp(S[i00+1],S[i10+1],dx), b0=lerp(S[i00+2],S[i10+2],dx), a0=lerp(S[i00+3],S[i10+3],dx);
  const r1=lerp(S[i01],S[i11],dx), g1=lerp(S[i01+1],S[i11+1],dx), b1=lerp(S[i01+2],S[i11+2],dx), a1=lerp(S[i01+3],S[i11+3],dx);
  return [ Math.round(lerp(r0,r1,dy)), Math.round(lerp(g0,g1,dy)), Math.round(lerp(b0,b1,dy)), Math.round(lerp(a0,a1,dy)) ];
}

/* ---------- repo helpers ---------- */
async function listPngs(folderApi){
  const r = await fetch(folderApi, { cache:'no-store' });
  if(!r.ok){ if(r.status===404) return []; throw new Error("GitHub API "+r.status); }
  const files = await r.json();
  return files.filter(f=>f.type==="file" && /\.png$/i.test(f.name))
              .map(f=>({ name:f.name.toLowerCase(), url:f.download_url }));
}
function loadImage(src){
  return new Promise((res,rej)=>{
    const img=new Image(); img.crossOrigin="anonymous";
    img.onload=()=>res(img); img.onerror=()=>rej(new Error("img "+src));
    img.src=src;
  });
}

/* ---------- planes ---------- */
function buildPlanes(){
  const hw = ROOM.width/2, hd = ROOM.depth/2, hh = ROOM.height/2;
  const base = [
    { id:"west",  n:[+1,0,0], u:[0,0,+1],  v:[0,1,0],    p:[-hw, hh, 0],        hu:hd, hv:hh, png:"west.png"  },
    { id:"east",  n:[-1,0,0], u:[0,0,-1],  v:[0,1,0],    p:[+hw, hh, 0],        hu:hd, hv:hh, png:"east.png"  },
    { id:"north", n:[0,0,+1], u:[+1,0,0],  v:[0,1,0],    p:[0, hh, -hd],        hu:hw, hv:hh, png:"north.png" },
    { id:"south", n:[0,0,-1], u:[-1,0,0],  v:[0,1,0],    p:[0, hh, +hd],        hu:hw, hv:hh, png:"south.png" },
    { id:"floor", n:[0,1,0],  u:[+1,0,0],  v:[0,0,+1],   p:[0, 0, 0],           hu:hw, hv:hd, png:"floor.png" },
    { id:"roof",  n:[0,-1,0], u:[+1,0,0],  v:[0,0,+1],   p:[0, ROOM.height, 0], hu:hw, hv:hd, png:"roof.png"  }
  ];
  return base.map(pl=>{
    const n = normalize(rotateY(pl.n, GLOBAL_YAW_DEG));
    const u = normalize(rotateY(pl.u, GLOBAL_YAW_DEG));
    const v = normalize(rotateY(pl.v, GLOBAL_YAW_DEG));
    const p = rotateY(pl.p, GLOBAL_YAW_DEG);
    p[1] += SHIFT_Y_M;
    return { ...pl, N:n, T:u, B:v, p };
  });
}

/* ---------- textures ---------- */
async function loadPlaneTextures(map, planes){
  const tex = {};
  for (const pl of planes){
    const colorUrl = map[pl.png];
    if (!colorUrl) continue;

    const normalUrl = map[pl.png.replace('.png','_n.png')];
    const bumpUrl   = map[pl.png.replace('.png','_b.png')];

    const imgC = await loadImage(colorUrl);
    const cC = document.createElement('canvas');
    cC.width  = Math.max(1, Math.round(imgC.naturalWidth  * SUPERSAMPLE));
    cC.height = Math.max(1, Math.round(imgC.naturalHeight * SUPERSAMPLE));
    const cx = cC.getContext('2d'); cx.imageSmoothingEnabled = true;
    cx.drawImage(imgC, 0,0, cC.width, cC.height);
    const C = cx.getImageData(0,0,cC.width,cC.height).data;

    let N=null, B=null;
    if (normalUrl){
      try{
        const imgN=await loadImage(normalUrl);
        const cN=document.createElement('canvas');
        cN.width=Math.max(1,Math.round(imgN.naturalWidth*SUPERSAMPLE));
        cN.height=Math.max(1,Math.round(imgN.naturalHeight*SUPERSAMPLE));
        const nx=cN.getContext('2d'); nx.imageSmoothingEnabled=true;
        nx.drawImage(imgN,0,0,cN.width,cN.height);
        N = nx.getImageData(0,0,cN.width,cN.height).data;
      }catch(e){}
    }
    if (!N && bumpUrl){
      try{
        const imgB=await loadImage(bumpUrl);
        const cB=document.createElement('canvas');
        cB.width=cC.width; cB.height=cC.height;
        const bx=cB.getContext('2d'); bx.imageSmoothingEnabled=true;
        bx.drawImage(imgB,0,0,cB.width,cB.height);
        B = bx.getImageData(0,0,cB.width,cB.height).data;
      }catch(e){}
    }
    tex[pl.id] = { color:{data:C,w:cC.width,h:cC.height}, normal: N?{data:N,w:cC.width,h:cC.height}:null, bump: B?{data:B,w:cC.width,h:cC.height}:null };
  }
  return tex;
}

/* ---------- WALL-WASHERS aimed at a band height ---------- */
function buildDownlights(planes){
  const lights = [];
  const walls = planes.filter(p => p.id==="north" || p.id==="south" || p.id==="east" || p.id==="west");

  const cone = DOWNLIGHTS.coneAngleDeg * D2R;
  const feather = DOWNLIGHTS.featherDeg * D2R;

  for (const w of walls){
    const fullSpan = w.hu * 2;
    const usable = Math.max(0, fullSpan - 2*DOWNLIGHTS.endMarginM);
    const start = -usable/2;

    for (let i=0;i<DOWNLIGHTS.perWall;i++){
      const t = (i + 0.5) / DOWNLIGHTS.perWall;
      const along = start + usable * t;

      // mount near the ceiling, slightly out from the wall
      const nearCeiling = add(w.p, mul(w.B, w.hv));
      const downFromEdge = add(nearCeiling, mul(w.B, -DOWNLIGHTS.belowCeilingM));
      const offWall = add(downFromEdge, mul(w.N, -DOWNLIGHTS.offWallM));
      const pos = add(offWall, mul(w.T, along));

      // target a point on the wall at the desired band height
      const clampY = Math.max(0.05, Math.min(ROOM.height - 0.05, WASH_BAND_Y_M));
      // convert desired world Y to the plane-local v (B axis) offset from plane origin p (at +hh)
      const worldY = clampY;
      const targetLocal = [ w.p[0], worldY, w.p[2] ];
      // translate along T by 'along'
      const targetAlong = add(targetLocal, mul(w.T, along));
      // nudge into the wall slightly to ensure hit
      const target = add(targetAlong, mul(w.N, 1e-3));

      const dir = normalize(sub(target, pos)); // light -> point

      lights.push({
        pos,
        dir,
        cone,
        feather,
        intensity: DOWNLIGHTS.intensity,
        range: DOWNLIGHTS.range
      });
    }
  }
  return lights;
}

/* ---------- lighting math ---------- */
function spotContribution(light, P, N){
  const LP = sub(P, light.pos);
  const dist = Math.hypot(LP[0],LP[1],LP[2]);
  if (dist <= 1e-6 || dist > light.range) return 0.0;

  const V = normalize(LP);             // light -> point (cone test)
  const L = normalize(mul(V, -1));     // point -> light (lambert)

  const cosA = dot(V, normalize(light.dir));
  const angle = Math.acos(Math.max(-1, Math.min(1, cosA)));
  if (angle > light.cone) return 0.0;

  const inner = Math.max(0, light.cone - light.feather);
  let spot = 1.0;
  if (angle > inner){
    const t = (light.cone - angle) / (light.cone - inner);
    spot = t*t*(3 - 2*t);
  }

  const lambert = Math.max(0, dot(N, L));
  const att = Math.max(0, 1.0 - (dist / light.range));
  const fall = att*att;
  return light.intensity * lambert * spot * fall;
}

function visibleFromLight(light, P, planes, selfPlane){
  if (!SHADOWS) return 1.0;
  const LP = sub(P, light.pos);
  const distLP = Math.hypot(LP[0],LP[1],LP[2]);
  const d = normalize(LP);
  for (const pl of planes){
    if (pl === selfPlane) continue;
    const n_dot_d = dot(pl.N, d);
    if (Math.abs(n_dot_d) <= 1e-9) continue;
    const t = dot(pl.N, [pl.p[0]-light.pos[0], pl.p[1]-light.pos[1], pl.p[2]-light.pos[2]]) / n_dot_d;
    if (t <= SHADOW_EPS || t >= distLP - SHADOW_EPS) continue;

    const Hx = light.pos[0] + t*d[0];
    const Hy = light.pos[1] + t*d[1];
    const Hz = light.pos[2] + t*d[2];
    const rel = [Hx - pl.p[0], Hy - pl.p[1], Hz - pl.p[2]];
    const cu = dot(rel, pl.T), cv = dot(rel, pl.B);
    if (Math.abs(cu) <= pl.hu && Math.abs(cv) <= pl.hv) return 0.0;
  }
  return 1.0;
}

/* ---------- shading helpers ---------- */
function sampleColor(tex, u, v){
  const {data,w,h} = tex.color;
  if (USE_BILINEAR) return sampleBilinear(data, w, h, u, v);
  const sx=Math.min(w-1,Math.max(0,Math.floor(u*w)));
  const sy=Math.min(h-1,Math.max(0,Math.floor(v*h)));
  const si=(sy*w+sx)*4;
  return [data[si],data[si+1],data[si+2],data[si+3]];
}
function sampleNormal(tex, u, v){
  const {data,w,h} = tex.normal;
  const [r,g,b] = USE_BILINEAR ? sampleBilinear(data,w,h,u,v) : (()=>{const sx=Math.min(w-1,Math.max(0,Math.floor(u*w))); const sy=Math.min(h-1,Math.max(0,Math.floor(v*h))); const si=(sy*w+sx)*4; return [data[si],data[si+1],data[si+2]];})();
  const nx = (r/255)*2-1, ny=(g/255)*2-1, nz=(b/255)*2-1;
  return normalize([nx, ny, nz]);
}
function sampleBump(tex, u, v){
  const {data,w,h} = tex.bump;
  function height(U,V){
    const fx=Math.max(0,Math.min(w-1,U*(w-1)));
    const fy=Math.max(0,Math.min(h-1,V*(h-1)));
    const x=Math.round(fx), y=Math.round(fy);
    const i=(y*w+x)*4;
    return data[i]*0.299 + data[i+1]*0.587 + data[i+2]*0.114;
  }
  const du=BUMP_EPS, dv=BUMP_EPS;
  const hC=height(u,v), hR=height(Math.min(1,u+du),v), hU=height(u,Math.max(0,v-dv));
  const dhdu=(hR-hC)/255.0, dhdv=(hU-hC)/255.0;
  return normalize([ -BUMP_SCALE*dhdu, -BUMP_SCALE*dhdv, 1.0 ]);
}

/* ---------- RAYCAST ---------- */
function intersectRayPlanes(ray, planes){
  let bestT = Infinity, hit = null;
  for(const pl of planes){
    const n_dot_d = dot(pl.N, ray);
    if (Math.abs(n_dot_d) <= 1e-9) continue;
    const t = dot(pl.N, [pl.p[0], pl.p[1]-ROOM.eyeY, pl.p[2]]) / n_dot_d;
    if (t <= 0 || t >= bestT) continue;

    const Hx=t*ray[0], Hy=ROOM.eyeY+t*ray[1], Hz=t*ray[2];
    const rel=[Hx-pl.p[0], Hy-pl.p[1], Hz-pl.p[2]];
    const cu=dot(rel, pl.T), cv=dot(rel, pl.B);
    if (Math.abs(cu) > pl.hu || Math.abs(cv) > pl.hv) continue;

    const u = (cu + pl.hu) / (2*pl.hu);
    const v = (pl.hv - cv) / (2*pl.hv);
    bestT = t;
    hit = { pl, u, v, P:[Hx,Hy,Hz], V: normalize(mul(ray,-1)) };
  }
  return hit;
}

/* ---------- BAKERS ---------- */
function bakeLit(planes, textures, lights){
  const W0=OUTPUT.width, H0=OUTPUT.height;
  const W=Math.max(1,Math.round(W0*SUPERSAMPLE));
  const H=Math.max(1,Math.round(H0*SUPERSAMPLE));
  const cvs=el('#bake'); cvs.width=W; cvs.height=H;
  const ctx=cvs.getContext('2d',{willReadFrequently:true});

  ctx.fillStyle=`rgba(${BACKGROUND_RGBA[0]},${BACKGROUND_RGBA[1]},${BACKGROUND_RGBA[2]},${BACKGROUND_RGBA[3]/255})`;
  ctx.fillRect(0,0,W,H);
  const img = ctx.getImageData(0,0,W,H);
  const D = img.data;

  for(let y=0;y<H;y++){
    const pitch = 90 - (y+0.5)*180/H;
    for(let x=0;x<W;x++){
      const yaw = (x+0.5)*360/W - 180;
      const ray = dirFromYawPitch(yaw, pitch);
      const hit = intersectRayPlanes(ray, planes);
      if(!hit) continue;

      const tex = textures[hit.pl.id];
      if (!tex) continue;
      let [r,g,b,a] = sampleColor(tex, hit.u, hit.v);
      if (a===0) continue;

      let Nw = hit.pl.N;
      if (tex.normal){
        const Nt = sampleNormal(tex, hit.u, hit.v);
        Nw = normalize([
          hit.pl.T[0]*Nt[0] + hit.pl.B[0]*Nt[1] + hit.pl.N[0]*Nt[2],
          hit.pl.T[1]*Nt[0] + hit.pl.B[1]*Nt[1] + hit.pl.N[1]*Nt[2],
          hit.pl.T[2]*Nt[0] + hit.pl.B[2]*Nt[1] + hit.pl.N[2]*Nt[2]
        ]);
      }else if (tex.bump){
        const Nt = sampleBump(tex, hit.u, hit.v);
        Nw = normalize([
          hit.pl.T[0]*Nt[0] + hit.pl.B[0]*Nt[1] + hit.pl.N[0]*Nt[2],
          hit.pl.T[1]*Nt[0] + hit.pl.B[1]*Nt[1] + hit.pl.N[1]*Nt[2],
          hit.pl.T[2]*Nt[0] + hit.pl.B[2]*Nt[1] + hit.pl.N[2]*Nt[2]
        ]);
      }

      let Lsum = AMBIENT, spec = 0.0;
      for (const Lsrc of lights){
        const vis = visibleFromLight(Lsrc, hit.P, planes, hit.pl);
        if (vis <= 0) continue;
        const contrib = spotContribution(Lsrc, hit.P, Nw) * vis;
        if (contrib <= 0) continue;
        Lsum += contrib;

        if (SPECULAR > 0){
          const Ldir = normalize(sub(Lsrc.pos, hit.P));
          const R = reflect(mul(Ldir,-1), Nw);
          const rv = Math.max(0, dot(R, hit.V));
          spec += SPECULAR * Math.pow(rv, SHININESS) * contrib;
        }
      }
      Lsum = Math.min(2.0, Lsum);

      const di = (y*W + x)*4;
      D[di  ] = Math.round(r * Lsum + 255 * spec);
      D[di+1] = Math.round(g * Lsum + 255 * spec);
      D[di+2] = Math.round(b * Lsum + 255 * spec);
      D[di+3] = a;
    }
  }

  ctx.putImageData(img,0,0);
  if (SUPERSAMPLE!==1.0){
    const final=document.createElement('canvas');
    final.width=W0; final.height=H0;
    const fx=final.getContext('2d'); fx.imageSmoothingEnabled=true;
    fx.drawImage(cvs,0,0,W,H,0,0,W0,H0);
    cvs.width=W0; cvs.height=H0;
    const gx=cvs.getContext('2d'); gx.drawImage(final,0,0);
  }
  return cvs;
}

/* Exporters */
function bakeGeneric(planes, pixelFn){
  const W0=OUTPUT.width, H0=OUTPUT.height;
  const W=Math.max(1,Math.round(W0*SUPERSAMPLE));
  const H=Math.max(1,Math.round(H0*SUPERSAMPLE));
  const cvs=el('#bake'); cvs.width=W; cvs.height=H;
  const ctx=cvs.getContext('2d',{willReadFrequently:true});
  ctx.clearRect(0,0,W,H);
  const img = ctx.getImageData(0,0,W,H);
  const D = img.data;
  for(let y=0;y<H;y++){
    const pitch = 90 - (y+0.5)*180/H;
    for(let x=0;x<W;x++){
      const yaw = (x+0.5)*360/W - 180;
      const ray = dirFromYawPitch(yaw, pitch);
      const hit = intersectRayPlanes(ray, planes);
      const di = (y*W + x)*4;
      if(!hit){ D[di+3]=0; continue; }
      const [r,g,b,a] = pixelFn(hit);
      D[di  ]=r; D[di+1]=g; D[di+2]=b; D[di+3]=a;
    }
  }
  ctx.putImageData(img,0,0);
  if (SUPERSAMPLE!==1.0){
    const final=document.createElement('canvas');
    final.width=W0; final.height=H0;
    const fx=final.getContext('2d'); fx.imageSmoothingEnabled=true;
    fx.drawImage(cvs,0,0,W,H,0,0,W0,H0);
    cvs.width=W0; cvs.height=H0;
    const gx=cvs.getContext('2d'); gx.drawImage(final,0,0);
  }
  return cvs;
}
function bakeColour(planes, textures){
  return bakeGeneric(planes, (hit)=>{
    const tex = textures[hit.pl.id]; if (!tex) return [0,0,0,0];
    return sampleColor(tex, hit.u, hit.v);
  });
}
function bakeNormal(planes, textures){
  return bakeGeneric(planes, (hit)=>{
    const Nw = hit.pl.N;
    return [
      Math.round((Nw[0]*0.5 + 0.5)*255),
      Math.round((Nw[1]*0.5 + 0.5)*255),
      Math.round((Nw[2]*0.5 + 0.5)*255),
      255
    ];
  });
}
function bakeHeight(planes, textures){
  return bakeGeneric(planes, (hit)=>{
    const tex = textures[hit.pl.id]; if (!tex) return [128,128,128,255];
    if (tex.bump){
      const {data,w,h} = tex.bump;
      const [r,g,b] = USE_BILINEAR ? sampleBilinear(data,w,h,hit.u,hit.v) : (()=>{
        const sx=Math.min(w-1,Math.max(0,Math.floor(hit.u*w)));
        const sy=Math.min(h-1,Math.max(0,Math.floor(hit.v*h)));
        const si=(sy*w+sx)*4;
        return [data[si],data[si+1],data[si+2]];
      })();
      const y = Math.round(0.299*r + 0.587*g + 0.114*b);
      return [y,y,y,255];
    }
    return [128,128,128,255];
  });
}

/* ---------- IO helpers ---------- */
async function listAndLoad(){
  const files = await listPngs(WALLS_API);
  const map = Object.create(null);
  files.forEach(f => map[f.name] = f.url);
  const planes = buildPlanes();
  const textures = await loadPlaneTextures(map, planes);
  return { planes, textures };
}
function canvasToBlobURL(canvas){
  return new Promise(res => canvas.toBlob(b => res(URL.createObjectURL(b)), "image/png", 0.95));
}
async function downloadCanvas(canvas, filename){
  const url = await canvasToBlobURL(canvas);
  const a = document.createElement('a');
  a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

/* ---------- viewer ---------- */
function startViewer(panoUrl){
  pannellum.viewer('viewer', {
    type: 'equirectangular',
    panorama: panoUrl,
    autoLoad: true,
    showControls: true,
    yaw: 0, pitch: 0, hfov: 85, minHfov: 40, maxHfov: 110,
    backgroundColor: [11,13,16]
  });
}

/* ---------- main + UI ---------- */
let cachedBakeURL = null;
(async function main(){
  try{
    toast('Loading walls…');
    const { planes, textures } = await listAndLoad();
    toast('Baking lit panorama…');
    const lights = buildDownlights(planes);
    const litCanvas = bakeLit(planes, textures, lights);
    cachedBakeURL = await canvasToBlobURL(litCanvas);
    startViewer(cachedBakeURL);

    // Download buttons
    document.getElementById('dlColor').onclick = async ()=>{
      toast('Baking colour map…');
      const c = bakeColour(planes, textures);
      await downloadCanvas(c, 'gallery_zero_colour.png');
      toast('Colour map saved');
    };
    document.getElementById('dlNormal').onclick = async ()=>{
      toast('Baking normal map…');
      const c = bakeNormal(planes, textures);
      await downloadCanvas(c, 'gallery_zero_normal_world.png');
      toast('Normal map saved');
    };
    document.getElementById('dlHeight').onclick = async ()=>{
      toast('Baking height map…');
      const c = bakeHeight(planes, textures);
      await downloadCanvas(c, 'gallery_zero_height.png');
      toast('Height map saved');
    };
    document.getElementById('dlLit').onclick = async ()=>{
      toast('Saving lit panorama…');
      const c = bakeLit(planes, textures, lights);
      await downloadCanvas(c, 'gallery_zero_lit.png');
      toast('Lit panorama saved');
    };
  }catch(err){
    console.error(err);
    toast('Setup failed. Check /walls names & repo visibility.');
  }
})();
</script>
</body>
</html>
