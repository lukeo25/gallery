<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Welcome to Luke O'Donnell's Gallery</title>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.css">
<script src="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.js"></script>

<style>
  html,body{height:100%;margin:0;background:#0b0d10;color:#e7ecf2;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  header{padding:10px 14px;background:#12151a;border-bottom:1px solid #1e2230;display:flex;align-items:center;justify-content:center}
  header h1{margin:0;font-size:18px;font-weight:700;letter-spacing:.2px}
  #viewer{height:calc(100vh - 56px)}
  #bake{display:none}
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:20px;background:#0f141b;color:#d4ddea;padding:10px 14px;border-radius:10px;font-size:13px;border:1px solid #223148;display:none;z-index:30}
</style>
</head>
<body>
  <header>
    <h1>Welcome to Luke O'Donnell's Gallery</h1>
  </header>

  <div id="viewer"></div>
  <canvas id="bake"></canvas>
  <div id="toast" class="toast"></div>

<script>
/* ===================== CONFIG ===================== */
const GH_USER = "lukeo25";
const GH_REPO = "gallery";
const WALLS_API = `https://api.github.com/repos/${GH_USER}/${GH_REPO}/contents/walls`;

/* Room (meters) and alignment */
const ROOM = { width: 10.0, depth: 10.0, height: 3.0, eyeY: 1.6 };
const GLOBAL_YAW_DEG = 0;   // rotate whole room if needed (try 90 / -90 / 180)
const SHIFT_Y_M = 0.0;      // nudge room up/down

/* Output panorama size & quality */
const OUTPUT = { width: 4096, height: 2048 };
const SUPERSAMPLE = 1.25;           // 1.0..2.0 (higher = crisper, slower)
const USE_BILINEAR = true;          // bilinear sampling for textures
const BACKGROUND_RGBA = [255,255,255,255]; // background color if nothing hits

/* Lighting */
const AMBIENT = 0.35;               // 0..1 ambient term
const DIFFUSE = 0.75;               // 0..1 diffuse intensity
const SPECULAR = 0.15;              // 0..1 specular intensity
const SHININESS = 32.0;             // specular power
// Directional light (world space) â€” edit to taste:
const LIGHT_DIR_WORLD = normalize([ -0.4, 0.8, -0.4 ]); // coming from above-left-front

/* Bump/Normal settings */
const BUMP_SCALE = 1.5;             // strength for height (bump) maps (world units per uv)
const BUMP_EPS = 1.0/1024.0;        // uv delta for gradient on bump maps
/* =================================================== */

const el = q => document.querySelector(q);
function toast(msg,ms=2000){ const t=el('#toast'); t.textContent=msg; t.style.display='block'; clearTimeout(toast._h); toast._h=setTimeout(()=>t.style.display='none',ms); }

/* ---------- math utils ---------- */
const D2R=Math.PI/180, R2D=180/Math.PI;
function normalize(v){ const L=Math.hypot(v[0],v[1],v[2])||1; return [v[0]/L, v[1]/L, v[2]/L]; }
function dot(a,b){ return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
function add(a,b){ return [a[0]+b[0], a[1]+b[1], a[2]+b[2]]; }
function sub(a,b){ return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
function mul(a,k){ return [a[0]*k, a[1]*k, a[2]*k]; }
function reflect(I,N){ // reflect I around N; both normalized
  const dn = dot(I,N);
  return sub(I, mul(N, 2*dn));
}
function dirFromYawPitch(yawDeg,pitchDeg){
  const y=yawDeg*D2R, p=pitchDeg*D2R;
  const cp=Math.cos(p), sp=Math.sin(p), cy=Math.cos(y), sy=Math.sin(y);
  return [cp*cy, sp, cp*sy];
}
function rotateY(v, yawDeg){
  const y=yawDeg*D2R, c=Math.cos(y), s=Math.sin(y);
  const x=v[0], z=v[2];
  return [c*x + s*z, v[1], -s*x + c*z];
}

/* ---------- sampling ---------- */
function sampleBilinear(S, sw, sh, u, v){
  const fx = Math.max(0, Math.min(sw-1, u * (sw-1)));
  const fy = Math.max(0, Math.min(sh-1, v * (sh-1)));
  const x0 = Math.floor(fx), y0 = Math.floor(fy);
  const x1 = Math.min(sw-1, x0+1), y1 = Math.min(sh-1, y0+1);
  const dx = fx - x0, dy = fy - y0;
  const i00 = (y0*sw + x0) * 4, i10 = (y0*sw + x1) * 4;
  const i01 = (y1*sw + x0) * 4, i11 = (y1*sw + x1) * 4;
  function lerp(a,b,t){ return a + (b-a)*t; }
  const r0 = lerp(S[i00], S[i10], dx), g0 = lerp(S[i00+1], S[i10+1], dx), b0 = lerp(S[i00+2], S[i10+2], dx), a0 = lerp(S[i00+3], S[i10+3], dx);
  const r1 = lerp(S[i01], S[i11], dx), g1 = lerp(S[i01+1], S[i11+1], dx), b1 = lerp(S[i01+2], S[i11+2], dx), a1 = lerp(S[i01+3], S[i11+3], dx);
  return [
    Math.round(lerp(r0, r1, dy)),
    Math.round(lerp(g0, g1, dy)),
    Math.round(lerp(b0, b1, dy)),
    Math.round(lerp(a0, a1, dy))
  ];
}

/* ---------- repo ---------- */
async function listPngs(folderApi){
  const r = await fetch(folderApi, { cache:'no-store' });
  if(!r.ok){ if(r.status===404) return []; throw new Error("GitHub API "+r.status); }
  const files = await r.json();
  return files.filter(f=>f.type==="file" && /\.png$/i.test(f.name))
              .map(f=>({ name:f.name.toLowerCase(), url:f.download_url }));
}
function loadImage(src){
  return new Promise((res,rej)=>{
    const img=new Image(); img.crossOrigin="anonymous";
    img.onload=()=>res(img); img.onerror=()=>rej(new Error("img "+src));
    img.src=src;
  });
}

/* ---------- plane setup ---------- */
function buildPlanes(){
  const hw = ROOM.width/2, hd = ROOM.depth/2, hh = ROOM.height/2;
  const base = [
    { id:"west",  n:[+1,0,0], u:[0,0,+1],  v:[0,1,0],    p:[-hw, hh, 0],        hu:hd, hv:hh, png:"west.png"  },
    { id:"east",  n:[-1,0,0], u:[0,0,-1],  v:[0,1,0],    p:[+hw, hh, 0],        hu:hd, hv:hh, png:"east.png"  },
    { id:"north", n:[0,0,+1], u:[+1,0,0],  v:[0,1,0],    p:[0, hh, -hd],        hu:hw, hv:hh, png:"north.png" },
    { id:"south", n:[0,0,-1], u:[-1,0,0],  v:[0,1,0],    p:[0, hh, +hd],        hu:hw, hv:hh, png:"south.png" },
    { id:"floor", n:[0,1,0],  u:[+1,0,0],  v:[0,0,+1],   p:[0, 0, 0],           hu:hw, hv:hd, png:"floor.png" },
    { id:"roof",  n:[0,-1,0], u:[+1,0,0],  v:[0,0,+1],   p:[0, ROOM.height, 0], hu:hw, hv:hd, png:"roof.png"  }
  ];
  return base.map(pl=>{
    const n = normalize(rotateY(pl.n, GLOBAL_YAW_DEG));
    const u = normalize(rotateY(pl.u, GLOBAL_YAW_DEG));
    const v = normalize(rotateY(pl.v, GLOBAL_YAW_DEG));
    const p = rotateY(pl.p, GLOBAL_YAW_DEG);
    p[1] += SHIFT_Y_M;
    const T = u, B = v, N = n; // tangent frame
    return { ...pl, n:N, u:T, v:B, p, T, B, N };
  });
}

/* ---------- loading textures (albedo + normal/bump) ---------- */
async function loadPlaneTextures(map, planes){
  const tex = {};
  for (const pl of planes){
    const colorUrl = map[pl.png];
    if (!colorUrl) continue;

    const normalUrl = map[pl.png.replace('.png','_n.png')];
    const bumpUrl   = map[pl.png.replace('.png','_b.png')];

    // Color
    const imgC = await loadImage(colorUrl);
    const cC = document.createElement('canvas');
    cC.width  = Math.max(1, Math.round(imgC.naturalWidth  * SUPERSAMPLE));
    cC.height = Math.max(1, Math.round(imgC.naturalHeight * SUPERSAMPLE));
    const cx = cC.getContext('2d'); cx.imageSmoothingEnabled = true;
    cx.drawImage(imgC, 0,0, cC.width, cC.height);
    const C = cx.getImageData(0,0,cC.width,cC.height).data;

    // Normal (optional)
    let N = null;
    if (normalUrl){
      try{
        const imgN = await loadImage(normalUrl);
        const cN = document.createElement('canvas');
        cN.width  = Math.max(1, Math.round(imgN.naturalWidth  * SUPERSAMPLE));
        cN.height = Math.max(1, Math.round(imgN.naturalHeight * SUPERSAMPLE));
        const nx = cN.getContext('2d'); nx.imageSmoothingEnabled = true;
        nx.drawImage(imgN, 0,0, cN.width, cN.height);
        N = nx.getImageData(0,0,cN.width,cN.height).data;
        tex[pl.id] = { color:{data:C,w:cC.width,h:cC.height}, normal:{data:N,w:cN.width,h:cN.height}, bump:null };
        continue; // prefer normal over bump if both exist
      }catch(e){ console.warn('normal map fail', pl.id, e); }
    }

    // Bump (optional)
    let B = null;
    if (bumpUrl){
      try{
        const imgB = await loadImage(bumpUrl);
        const cB = document.createElement('canvas');
        cB.width  = Math.max(1, Math.round(imgB.naturalWidth  * SUPERSAMPLE));
        cB.height = Math.max(1, Math.round(imgB.naturalHeight * SUPERSAMPLE));
        const bx = cB.getContext('2d'); bx.imageSmoothingEnabled = true;
        bx.drawImage(imgB, 0,0, cB.width, cB.height);
        B = bx.getImageData(0,0,cB.width,cB.height).data;
      }catch(e){ console.warn('bump map fail', pl.id, e); }
    }

    tex[pl.id] = { color:{data:C,w:cC.width,h:cC.height}, normal:null, bump: B ? {data:B,w:cC.width,h:cC.height} : null };
  }
  return tex;
}

/* ---------- shading helpers ---------- */
function sampleColor(tex, u, v){
  const {data,w,h} = tex.color;
  if (USE_BILINEAR){
    return sampleBilinear(data, w, h, u, v);
  }else{
    const sx = Math.min(w-1, Math.max(0, Math.floor(u * w)));
    const sy = Math.min(h-1, Math.max(0, Math.floor(v * h)));
    const si = (sy*w + sx) * 4;
    return [data[si], data[si+1], data[si+2], data[si+3]];
  }
}
function sampleNormal(tex, u, v){
  const {data,w,h} = tex.normal;
  const [r,g,b] = USE_BILINEAR ? sampleBilinear(data, w, h, u, v) : (()=>{
    const sx=Math.min(w-1,Math.max(0,Math.floor(u*w)));
    const sy=Math.min(h-1,Math.max(0,Math.floor(v*h)));
    const si=(sy*w+sx)*4; return [data[si],data[si+1],data[si+2]];
  })();
  // Tangent-space normal map in [0,255] -> [-1,1]
  const nx = (r/255)*2-1;
  const ny = (g/255)*2-1;
  const nz = (b/255)*2-1;
  return normalize([nx, ny, nz]);
}
function sampleBump(tex, u, v){
  // Return tangent-space normal from a grayscale height map via finite difference
  const {data,w,h} = tex.bump;
  function height(U,V){
    const fx = Math.max(0, Math.min(w-1, U*(w-1)));
    const fy = Math.max(0, Math.min(h-1, V*(h-1)));
    const x = Math.round(fx), y = Math.round(fy);
    const i = (y*w + x)*4;
    return data[i]*0.299 + data[i+1]*0.587 + data[i+2]*0.114; // luma
  }
  const du = BUMP_EPS, dv = BUMP_EPS;
  const hC = height(u,v);
  const hR = height(Math.min(1,u+du), v);
  const hU = height(u, Math.max(0,v-dv)); // remember v is top->bottom
  // Gradients (higher height => facing "up")
  const dhdu = (hR - hC) / 255.0;
  const dhdv = (hU - hC) / 255.0;
  // Tangent-space normal: x ~ -dH/du, y ~ -dH/dv, z ~ 1
  return normalize([ -BUMP_SCALE*dhdu, -BUMP_SCALE*dhdv, 1.0 ]);
}

/* ---------- main bake (nearest-hit + lighting) ---------- */
async function bakeRoom(){
  // Load file list
  const files = await listPngs(WALLS_API);
  const map = Object.create(null);
  files.forEach(f => map[f.name] = f.url);

  const planes = buildPlanes();
  const textures = await loadPlaneTextures(map, planes);

  const W0=OUTPUT.width, H0=OUTPUT.height;
  const W=Math.max(1,Math.round(W0*SUPERSAMPLE));
  const H=Math.max(1,Math.round(H0*SUPERSAMPLE));
  const cvs = el('#bake'); cvs.width=W; cvs.height=H;
  const ctx0 = cvs.getContext('2d', { willReadFrequently:true });

  // Background
  ctx0.fillStyle = `rgba(${BACKGROUND_RGBA[0]},${BACKGROUND_RGBA[1]},${BACKGROUND_RGBA[2]},${BACKGROUND_RGBA[3]/255})`;
  ctx0.fillRect(0,0,W,H);
  let imgData = ctx0.getImageData(0,0,W,H);
  const D = imgData.data;

  const eyeY = ROOM.eyeY;
  const L = LIGHT_DIR_WORLD; // normalized already

  for (let y=0; y<H; y++){
    const pitch = 90 - (y + 0.5) * 180 / H;
    for (let x=0; x<W; x++){
      const yaw = (x + 0.5) * 360 / W - 180;
      const ray = dirFromYawPitch(yaw, pitch);   // from eye (0,eyeY,0)

      let bestT = Infinity;
      let hit = null;

      for (const pl of planes){
        const n_dot_d = dot(pl.N, ray);
        if (Math.abs(n_dot_d) <= 1e-9) continue;

        const t = dot(pl.N, [pl.p[0], pl.p[1]-eyeY, pl.p[2]]) / n_dot_d;
        if (t <= 0 || t >= bestT) continue;

        const Hx = t*ray[0], Hy = eyeY + t*ray[1], Hz = t*ray[2];
        const rel = [Hx - pl.p[0], Hy - pl.p[1], Hz - pl.p[2]];
        const cu = dot(rel, pl.T);
        const cv = dot(rel, pl.B);
        if (Math.abs(cu) > pl.hu || Math.abs(cv) > pl.hv) continue;

        const u = (cu + pl.hu) / (2*pl.hu);
        const v = (pl.hv - cv) / (2*pl.hv); // top->bottom
        bestT = t;
        hit = { pl, u, v, viewDir: normalize(mul(ray, -1)) }; // V points toward camera
      }

      if (!hit) continue; // background already filled

      const tex = textures[hit.pl.id];
      if (!tex) continue;

      // Albedo
      let [r,g,b,a] = sampleColor(tex, hit.u, hit.v);
      if (a === 0) continue;

      // Base normal in world = plane normal
      let Nw = hit.pl.N;

      // Normal/bump?
      if (tex.normal){
        const Nt = sampleNormal(tex, hit.u, hit.v);     // tangent space
        // Tangent frame (T,B,N) -> world
        const T = hit.pl.T, B = hit.pl.B, N = hit.pl.N;
        Nw = normalize([
          T[0]*Nt[0] + B[0]*Nt[1] + N[0]*Nt[2],
          T[1]*Nt[0] + B[1]*Nt[1] + N[1]*Nt[2],
          T[2]*Nt[0] + B[2]*Nt[1] + N[2]*Nt[2]
        ]);
      } else if (tex.bump){
        const Nt = sampleBump(tex, hit.u, hit.v);       // from height â†’ tangent normal
        const T = hit.pl.T, B = hit.pl.B, N = hit.pl.N;
        Nw = normalize([
          T[0]*Nt[0] + B[0]*Nt[1] + N[0]*Nt[2],
          T[1]*Nt[0] + B[1]*Nt[1] + N[1]*Nt[2],
          T[2]*Nt[0] + B[2]*Nt[1] + N[2]*Nt[2]
        ]);
      }

      // Lighting
      const ndl = Math.max(0, dot(Nw, L));
      const diffuse = DIFFUSE * ndl;
      let spec = 0.0;
      if (SPECULAR > 0 && ndl > 0){
        const R = reflect(mul(L,-1), Nw);
        const rv = Math.max(0, dot(R, hit.viewDir));
        spec = SPECULAR * Math.pow(rv, SHININESS);
      }
      const lit = Math.min(1.0, AMBIENT + diffuse + spec);

      const di = (y*W + x)*4;
      D[di  ] = Math.round((r) * lit);
      D[di+1] = Math.round((g) * lit);
      D[di+2] = Math.round((b) * lit);
      D[di+3] = a;
    }
  }

  // Commit & downscale
  ctx0.putImageData(imgData, 0, 0);
  if (SUPERSAMPLE !== 1.0){
    const final = document.createElement('canvas');
    final.width = W0; final.height = H0;
    const fx = final.getContext('2d');
    fx.imageSmoothingEnabled = true;
    fx.drawImage(cvs, 0,0, W, H, 0,0, W0, H0);
    cvs.width = W0; cvs.height = H0;
    const gx = cvs.getContext('2d');
    gx.drawImage(final, 0, 0);
  }

  const blob = await new Promise(res => el('#bake').toBlob(res, "image/png", 0.95));
  return URL.createObjectURL(blob);
}

/* ---------- viewer ---------- */
function startViewer(panoUrl){
  pannellum.viewer('viewer', {
    type: 'equirectangular',
    panorama: panoUrl,
    autoLoad: true,
    showControls: true,
    yaw: 0, pitch: 0, hfov: 85, minHfov: 40, maxHfov: 110,
    backgroundColor: [11,13,16]
  });
}

/* ---------- go ---------- */
(async function main(){
  try{
    toast('Baking with bump/normal lightingâ€¦');
    const url = await bakeRoom();
    toast('Starting viewerâ€¦');
    startViewer(url);
  }catch(err){
    console.error(err);
    toast('Failed to bake (check /walls file names & that repo is public).');
  }
})();
</script>
</body>
</html>
