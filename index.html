<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Baked Equirect Gallery</title>

  <!-- Pannellum -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.css">
  <script src="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.js"></script>

  <style>
    html, body { height:100%; margin:0; background:#0b0d10; color:#e7ecf2; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    header { padding:10px 14px; background:#12151a; border-bottom:1px solid #1e2230; display:flex; gap:12px; align-items:center;}
    header h1{ margin:0; font-size:16px; font-weight:600 }
    header .hint{ opacity:.75; font-size:13px }
    #viewer{ height:calc(100vh - 48px) }

    /* Invisible (but clickable) hotspots */
    .hotspot-hit {
      width: 220px;              /* base size; pannellum scales this when scale:true */
      height: 140px;
      background: rgba(255,255,255,0.0);    /* fully transparent */
      border: 0;
      outline: none;
      cursor: pointer;
    }
    .hotspot-hit:focus{ box-shadow:0 0 0 2px #5da0ffaa; border-radius:6px }
    /* Toast */
    .toast{ position:fixed; left:50%; transform:translateX(-50%); bottom:20px; background:#0f141b; color:#d4ddea; padding:10px 14px; border-radius:10px; font-size:13px; border:1px solid #223148; display:none; z-index:30 }
    /* Hidden canvas used to bake the panorama+artworks */
    #bake { display:none }
  </style>
</head>
<body>
  <header>
    <h1>Baked Equirect Gallery</h1>
    <div class="hint">Images are composited into the pano; hotspots are transparent click areas.</div>
  </header>
  <div id="viewer"></div>
  <canvas id="bake"></canvas>
  <div id="toast" class="toast"></div>

  <script>
    /* ---------- Settings (no placeholders) ---------- */
    const GH_USER = "lukeo25";
    const GH_REPO = "gallery";
    const ARTWORKS_API = `https://api.github.com/repos/${GH_USER}/${GH_REPO}/contents/artworks`;
    const PANO_URL_RAW = "https://raw.githubusercontent.com/lukeo25/gallery/refs/heads/main/gallery/gallery001.png";

    /* Auto layout around the equator */
    const LAYOUT = { rows: 1, pitchTopDeg: 0, pitchRowGapDeg: -12, yawOffsetDeg: 0 };

    /* Artwork angular sizing (how big each picture is in the world). We keep constant height in degrees. */
    const ART_HEIGHT_DEG = 14;       // apparent height on the sphere
    const SHADOW = { enabled: true, blur: 16, color: "rgba(0,0,0,0.35)", offsetX: 0, offsetY: 6, border: "rgba(255,255,255,0.85)" };

    /* Hotspot base CSS size used by pannellum (scaled with zoom when scale:true) */
    const HOTSPOT_BASE_PX = { w: 220, h: 140 };

    /* ---------- Utilities ---------- */
    const el = q => document.querySelector(q);
    function toast(msg, ms=2400){ const t=el('#toast'); t.textContent=msg; t.style.display='block'; clearTimeout(toast._h); toast._h=setTimeout(()=>t.style.display='none',ms); }
    function normYaw(d){ d=((d+180)%360+360)%360-180; return d; } // [-180,180]
    function numFromName(n){ const m=/^(\d+)\.(png|jpg|jpeg|webp)$/i.exec(n); return m?parseInt(m[1],10):null; }

    function positionForIndex(i,total){
      const rows = Math.max(1, LAYOUT.rows|0);
      const perRow = Math.ceil(total/rows);
      const row = Math.floor(i/perRow);
      const idxInRow = i - row*perRow;
      const countRow = Math.min(perRow, total - row*perRow);
      const yawStep = 360 / Math.max(1, countRow);
      const yaw = -180 + (idxInRow + 0.5) * yawStep + LAYOUT.yawOffsetDeg;
      const pitch = LAYOUT.pitchTopDeg + row * LAYOUT.pitchRowGapDeg;
      return { yaw, pitch };
    }

    /* Draw with horizontal wrap-around: if x<0 or x+w>W, split across edges */
    function drawWrapped(ctx, img, x, y, w, h, W){
      // integer math not required; canvas accepts floats
      if (x >= 0 && x + w <= W){
        ctx.drawImage(img, x, y, w, h);
      } else {
        let x1 = x, w1 = w;
        while (x1 < 0) x1 += W;
        while (x1 >= W) x1 -= W;
        if (x1 + w1 > W){
          const wRight = W - x1;
          ctx.drawImage(img, 0, 0, img.naturalWidth * (wRight/w), img.naturalHeight, x1, y, wRight, h);
          const wLeft  = w1 - wRight;
          ctx.drawImage(img, img.naturalWidth * (wRight/w), 0, img.naturalWidth * (wLeft/w), img.naturalHeight, 0, y, wLeft, h);
        } else {
          ctx.drawImage(img, x1, y, w1, h);
        }
      }
    }

    async function listArtworks(){
      const r = await fetch(ARTWORKS_API, { cache:'no-store' });
      if(!r.ok) throw new Error('GitHub API '+r.status);
      const files = await r.json();
      return files
        .filter(f=>f.type==='file' && /\.(png|jpg|jpeg|webp)$/i.test(f.name))
        .map(f=>({ n:numFromName(f.name), name:f.name, url:f.download_url }))
        .filter(a=>Number.isFinite(a.n))
        .sort((a,b)=>a.n-b.n);
    }

    function loadImage(src){
      return new Promise((resolve, reject)=>{
        const img=new Image(); img.crossOrigin='anonymous';
        img.onload=()=>resolve(img); img.onerror=()=>reject(new Error('img '+src));
        img.src=src;
      });
    }

    /* ---------- Bake step: panorama + artworks => blob URL ---------- */
    async function bakeComposite(){
      // Load pano and file list
      const [panoImg, items] = await Promise.all([ loadImage(PANO_URL_RAW), listArtworks() ]);

      // Load all artworks
      const imgs = await Promise.all(items.map(i=>loadImage(i.url)));

      // Setup canvas
      const W = panoImg.naturalWidth;
      const H = panoImg.naturalHeight;
      const cvs = el('#bake'); cvs.width=W; cvs.height=H;
      const ctx = cvs.getContext('2d');

      // Draw base pano
      ctx.drawImage(panoImg, 0, 0, W, H);

      // Optional: nicer look with white stroke & shadow to mimic frames
      function drawFramed(img, x, y, w, h){
        if (SHADOW.enabled){
          ctx.save();
          ctx.shadowColor = SHADOW.color;
          ctx.shadowBlur = SHADOW.blur;
          ctx.shadowOffsetX = SHADOW.offsetX;
          ctx.shadowOffsetY = SHADOW.offsetY;
          drawWrapped(ctx, img, x, y, w, h, W);
          ctx.restore();
          // white border
          ctx.save();
          ctx.lineWidth = Math.max(2, Math.min(w,h)*0.02);
          ctx.strokeStyle = SHADOW.border;
          ctx.beginPath();
          // handle wrap by stroking on both sides if needed
          if (x >= 0 && x + w <= W){
            ctx.rect(x, y, w, h);
            ctx.stroke();
          } else {
            // right slice
            let x1=x; while(x1<0) x1+=W; while(x1>=W) x1-=W;
            const wRight = Math.min(w, W-x1);
            ctx.rect(x1, y, wRight, h); ctx.stroke();
            // left slice
            if (wRight < w){
              const wLeft = w - wRight;
              ctx.beginPath(); ctx.rect(0, y, wLeft, h); ctx.stroke();
            }
          }
          ctx.restore();
        } else {
          drawWrapped(ctx, img, x, y, w, h, W);
        }
      }

      // Place each artwork: compute angular size from constant height, preserve aspect
      for (let i=0;i<items.length;i++){
        const meta = items[i];
        const img  = imgs[i];
        const pos  = positionForIndex(i, items.length);

        // Angular size -> pixel size
        const hDeg = ART_HEIGHT_DEG;
        const hPx  = H * (hDeg / 180);
        const aspect = img.naturalWidth / img.naturalHeight;
        const wPx  = hPx * aspect;

        // Convert yaw/pitch to pixel center
        const cx = W * ((normYaw(pos.yaw) + 180) / 360);
        const cy = H * ((90 - pos.pitch) / 180);

        const x = cx - wPx/2;
        const y = cy - hPx/2;

        drawFramed(img, x, y, wPx, hPx);

        // Store hotspot spec for later (yaw/pitch + approximate size)
        meta._yaw   = pos.yaw;
        meta._pitch = pos.pitch;
        meta._w     = HOTSPOT_BASE_PX.w; // visual is baked; hotspot only needs a sensible click size
        meta._h     = HOTSPOT_BASE_PX.h;
      }

      // Export to blob URL and return {url, items}
      const blob = await new Promise(res => cvs.toBlob(res, 'image/png', 0.95));
      const url  = URL.createObjectURL(blob);
      return { panoUrl:url, items };
    }

    /* ---------- Pannellum viewer with transparent hotspots ---------- */
    function startViewer(panoUrl, items){
      const viewer = pannellum.viewer('viewer', {
        type: 'equirectangular',
        panorama: panoUrl,
        autoLoad: true,
        showControls: true,
        yaw: 0, pitch: 0, hfov: 85, minHfov: 40, maxHfov: 110,
        backgroundColor: [11,13,16]
      });

      // Transparent hit areas
      items.forEach((art, i)=>{
        viewer.addHotSpot({
          yaw: art._yaw,
          pitch: art._pitch,
          scale: true,                         // scales with zoom; visuals are baked
          createTooltipFunc: (div, args)=>{
            div.className = 'hotspot-hit';
            // size the invisible hitbox (can tweak per aspect if you want)
            div.style.width  = args.w + 'px';
            div.style.height = args.h + 'px';
            div.setAttribute('aria-label', 'Artwork '+args.number);
            div.tabIndex = 0;
            div.addEventListener('click', ()=>openCard(args));
            div.addEventListener('keydown', e=>{
              if(e.key==='Enter' || e.key===' ') { e.preventDefault(); openCard(args); }
            });
          },
          createTooltipArgs: {
            number: art.n || i+1,
            title:  art.title || '',
            imageUrl: art.url,
            w: art._w,
            h: art._h
          }
        });
      });

      function openCard(a){
        // Basic popup using alert for brevity; replace with your card UI if you like
        alert((a.title ? a.title+'\n' : '') + 'Artwork #' + a.number);
      }

      viewer.on('load', ()=>toast('Gallery loaded'));
      viewer.on('error', e=>{ console.error(e); toast('Pannellum error'); });
    }

    /* ---------- Run ---------- */
    (async function main(){
      try{
        toast('Baking panorama…');
        const { panoUrl, items } = await bakeComposite();
        toast('Starting viewer…');
        startViewer(panoUrl, items);
      }catch(err){
        console.error(err);
        toast('Failed to bake or load. Is repo public and folders correct?');
      }
    })();
  </script>
</body>
</html>
