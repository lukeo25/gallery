<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Algorithmic Baked Equirect Gallery</title>

  <!-- Pannellum -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.css">
  <script src="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.js"></script>

  <style>
    html,body{height:100%;margin:0;background:#0b0d10;color:#e7ecf2;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    header{padding:10px 14px;background:#12151a;border-bottom:1px solid #1e2230;display:flex;gap:12px;align-items:center}
    header h1{margin:0;font-size:16px;font-weight:600}
    header .hint{opacity:.75;font-size:13px}
    #viewer{height:calc(100vh - 48px)}
    #bake{display:none}

    /* Transparent clickable hotspot */
    .hotspot-hit{
      width:220px;height:140px;background:rgba(255,255,255,0);border:0;outline:none;cursor:pointer
    }
    .hotspot-hit:focus{box-shadow:0 0 0 2px #5da0ffaa;border-radius:6px}
    .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:20px;background:#0f141b;color:#d4ddea;padding:10px 14px;border-radius:10px;font-size:13px;border:1px solid #223148;display:none;z-index:30}
  </style>
</head>
<body>
  <header>
    <h1>Algorithmic Baked Equirect Gallery</h1>
    <div class="hint">Artworks are warped onto wall planes; hotspots are transparent click areas.</div>
  </header>

  <div id="viewer"></div>
  <canvas id="bake"></canvas>
  <div id="toast" class="toast"></div>

  <script>
    /* ===================== Config ===================== */
    const GH_USER = "lukeo25";
    const GH_REPO = "gallery";
    const ARTWORKS_API = `https://api.github.com/repos/${GH_USER}/${GH_REPO}/contents/artworks`;
    const PANO_URL_RAW  = "https://raw.githubusercontent.com/lukeo25/gallery/refs/heads/main/gallery/gallery001.png";

    // Camera at origin, looking at equirect pano. "Walls" are vertical planes at distance R.
    const R = 1.0;                              // distance from viewer to each wall plane
    const ART_HEIGHT_DEG = 14;                  // how tall an artwork appears (angular) when centered
    const LAYOUT = { rows: 1, yawOffsetDeg: 0, pitchDeg: 0 }; // all artworks on equator; auto-spaced by index

    // Visual frame baked into the pano (soft border / shadow). Set enabled:false for pure images.
    const FRAME = { enabled: true, shadow: "rgba(0,0,0,0.35)", blur: 14, offsetX: 0, offsetY: 6, border: "rgba(255,255,255,0.85)" };

    // Hotspot base CSS size (Pannellum scales it with zoom when scale:true)
    const HOTSPOT_BASE_PX = { w: 220, h: 140 };

    // Performance guard (ROI margins in degrees)
    const ROI_MARGIN_DEG = 2.0;                // expand computed yaw/pitch bounds a bit
    /* ================================================== */

    const el = q => document.querySelector(q);
    function toast(msg, ms=2200){ const t=el('.toast'); t.textContent=msg; t.style.display='block'; clearTimeout(toast._h); toast._h=setTimeout(()=>t.style.display='none',ms); }

    // Degrees/radians helpers
    const D2R = Math.PI/180, R2D = 180/Math.PI;
    const sin = Math.sin, cos = Math.cos, atan2 = Math.atan2, asin = Math.asin, sqrt = Math.sqrt, abs = Math.abs, tan = Math.tan;

    function normYawDeg(a){ a = ((a + 180) % 360 + 360) % 360 - 180; return a; }

    function yawPitchFromPoint(p){
      const len = Math.hypot(p[0], p[1], p[2]);
      const yaw = atan2(p[2], p[0]) * R2D;          // [-180,180]
      const pitch = asin(p[1]/len) * R2D;           // [-90,90]
      return { yaw: yaw, pitch: pitch };
    }

    function dirFromYawPitch(yawDeg, pitchDeg){
      const yaw = yawDeg * D2R, pitch = pitchDeg * D2R;
      const cp = cos(pitch), sp = sin(pitch), cy = cos(yaw), sy = sin(yaw);
      return [cp*cy, sp, cp*sy]; // unit direction
    }

    function listArtworks(){
      return fetch(ARTWORKS_API, { cache:'no-store' })
        .then(r => { if(!r.ok) throw new Error("GitHub API "+r.status); return r.json(); })
        .then(files => files
          .filter(f => f.type === "file" && /\.(png|jpg|jpeg|webp)$/i.test(f.name))
          .map(f => {
            const m = /^(\d+)\.(png|jpg|jpeg|webp)$/i.exec(f.name);
            const n = m ? parseInt(m[1], 10) : null;
            return { n, name: f.name, url: f.download_url };
          })
          .filter(x => Number.isFinite(x.n))
          .sort((a,b) => a.n - b.n)
        );
    }

    function loadImage(src){
      return new Promise((res, rej)=>{
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => res(img);
        img.onerror = () => rej(new Error("img "+src));
        img.src = src;
      });
    }

    // Compute artwork plane placement from its index
    function placementForIndex(i, total, aspect){
      // evenly spaced around 360°
      const yaw = normYawDeg(-180 + (i + 0.5) * (360 / total) + LAYOUT.yawOffsetDeg);
      const pitch = LAYOUT.pitchDeg; // center on equator
      // Convert desired angular height to world height on a plane at distance R.
      // Small-angle derivation: deltaPitch ≈ 2*atan((h/2)/R)  =>  h ≈ 2*R*tan(delta/2)
      const hWorld = 2 * R * Math.tan((ART_HEIGHT_DEG * D2R)/2);
      const wWorld = hWorld * aspect;

      // Plane normal faces the camera
      const n = [cos(yaw*D2R), 0, sin(yaw*D2R)];              // inward normal
      const u = [-sin(yaw*D2R), 0, cos(yaw*D2R)];             // horizontal axis along wall
      const v = [0, 1, 0];                                    // vertical axis
      const P0 = [n[0]*R, 0, n[2]*R];                         // a point on plane (center height 0)
      const C  = [P0[0], 0, P0[2]];                           // center of artwork at y=0

      return { yaw, pitch, n, u, v, C, wWorld, hWorld };
    }

    // Build a conservative yaw/pitch ROI around the artwork to limit per-pixel work
    function roiForArtwork(place){
      const dYaw = Math.atan((place.wWorld/2)/R) * R2D + ROI_MARGIN_DEG; // approximate
      const dPit = ART_HEIGHT_DEG/2 + ROI_MARGIN_DEG;
      return {
        yawMin: normYawDeg(place.yaw - dYaw),
        yawMax: normYawDeg(place.yaw + dYaw),
        pitchMin: place.pitch - dPit,
        pitchMax: place.pitch + dPit
      };
    }

    function inYawRange(yaw, minYaw, maxYaw){
      // handle seam [-180,180]: choose the smaller arc between min and max
      const a = normYawDeg(yaw - minYaw);
      const b = normYawDeg(maxYaw - minYaw);
      if (b < 0) return false;
      // When range crosses seam, b may be small negative if not normalized; ensure positive
      const span = (b+360)%360;
      const pos = (a+360)%360;
      return pos <= span;
    }

    // Alpha blend src over dst in place
    function blend(dst, di, sr, sg, sb, sa){
      const a = sa / 255;
      const ia = 1 - a;
      dst[di    ] = Math.round(sr * a + dst[di    ] * ia);
      dst[di + 1] = Math.round(sg * a + dst[di + 1] * ia);
      dst[di + 2] = Math.round(sb * a + dst[di + 2] * ia);
      dst[di + 3] = Math.round(255 * (a + (dst[di + 3]/255) * ia));
    }

    async function bakeComposite(){
      // Load pano + list + artwork images
      const [panoImg, files] = await Promise.all([ loadImage(PANO_URL_RAW), listArtworks() ]);
      const artImgs = await Promise.all(files.map(f => loadImage(f.url)));

      // Prepare destination canvas
      const W = panoImg.naturalWidth;
      const H = panoImg.naturalHeight;
      const cvs = el('#bake'); cvs.width = W; cvs.height = H;
      const ctx = cvs.getContext('2d');
      ctx.drawImage(panoImg, 0, 0, W, H);
      const dest = ctx.getImageData(0, 0, W, H);
      const D = dest.data;

      // For each artwork, compute placement and paint into dest image
      const items = [];
      for (let i=0; i<files.length; i++){
        const meta = files[i];
        const img = artImgs[i];
        const aspect = img.naturalWidth / img.naturalHeight;
        const place = placementForIndex(i, files.length, aspect);
        const roi = roiForArtwork(place);

        // For the hotspot later
        items.push({
          number: String(meta.n),
          yaw: place.yaw,
          pitch: place.pitch,
          url: meta.url,
          wPx: HOTSPOT_BASE_PX.w,
          hPx: HOTSPOT_BASE_PX.h
        });

        // Build a quick sampler for the artwork
        const sCvs = document.createElement('canvas');
        sCvs.width = img.naturalWidth; sCvs.height = img.naturalHeight;
        const sCtx = sCvs.getContext('2d');
        sCtx.drawImage(img, 0, 0);
        const sData = sCtx.getImageData(0, 0, sCvs.width, sCvs.height).data;

        // Convenience locals
        const n = place.n, u = place.u, v = place.v, C = place.C;
        const hw = place.wWorld / 2, hh = place.hWorld / 2;

        // Convert ROI degrees -> pixel rows / columns
        // Yaw span may cross seam; we won't convert to columns directly.
        const yMin = Math.max(0, Math.floor((90 - roi.pitchMax) / 180 * H));
        const yMax = Math.min(H-1, Math.ceil((90 - roi.pitchMin) / 180 * H));

        for (let y = yMin; y <= yMax; y++){
          const pitch = 90 - (y + 0.5) * 180 / H;      // center-of-pixel
          for (let x = 0; x < W; x++){
            const yaw = (x + 0.5) * 360 / W - 180;
            if (!inYawRange(yaw, roi.yawMin, roi.yawMax)) continue;

            // Ray direction for this pano pixel
            const d = dirFromYawPitch(yaw, pitch); // [dx,dy,dz]

            // Plane intersection: n·(t*d) = R  => t = R / (n·d)
            const nd = n[0]*d[0] + n[1]*d[1] + n[2]*d[2];
            if (nd <= 1e-6) continue;             // looking away / parallel

            const t = R / nd;
            const Hx = d[0]*t, Hy = d[1]*t, Hz = d[2]*t;   // hit point on plane
            // Vector from artwork center
            const rx = Hx - C[0], ry = Hy - C[1], rz = Hz - C[2];

            // Local coordinates (u to right, v up)
            const cu = rx*u[0] + ry*u[1] + rz*u[2];
            const cv = rx*v[0] + ry*v[1] + rz*v[2];

            if (abs(cu) > hw || abs(cv) > hh) continue; // outside rect

            // Map to artwork pixel (0..w-1, 0..h-1), origin top-left
            const uu = (cu + hw) / (2*hw);            // 0..1
            const vv = (hh - cv) / (2*hh);            // 0..1 (flip y)

            const sx = Math.min(sCvs.width - 1, Math.max(0, Math.floor(uu * sCvs.width)));
            const sy = Math.min(sCvs.height - 1, Math.max(0, Math.floor(vv * sCvs.height)));
            const si = (sy * sCvs.width + sx) * 4;

            const r = sData[si], g = sData[si+1], b = sData[si+2], a = sData[si+3];
            if (a === 0) continue;

            const di = (y * W + x) * 4;
            // Optional soft border/shadow: draw after blend for a subtle frame (skip for transparent pixels)
            blend(D, di, r, g, b, a);
          }
        }

        // Optional frame (simple white stroke + shadow) — approximate by re-painting edges in pano space.
        if (FRAME.enabled){
          // draw a thin expanded area by sampling the same rect with a 1px dilation in local coords
          // (cheap way to give a crisp border)
          const borderPx = 2; // pano-pixel thickness
          const expand = 1 + (borderPx / Math.max(W, H)) * 360 / (2*R2D); // tiny angular expansion
          // we just repeat the loop but sample a solid color at edges
          const yMin2 = yMin, yMax2 = yMax;
          for (let y = yMin2; y <= yMax2; y++){
            const pitch = 90 - (y + 0.5) * 180 / H;
            for (let x = 0; x < W; x++){
              const yaw = (x + 0.5) * 360 / W - 180;
              if (!inYawRange(yaw, roi.yawMin, roi.yawMax)) continue;
              const d = dirFromYawPitch(yaw, pitch);
              const nd = n[0]*d[0] + n[1]*d[1] + n[2]*d[2];
              if (nd <= 1e-6) continue;
              const t = R / nd;
              const Hx = d[0]*t, Hy = d[1]*t, Hz = d[2]*t;
              const rx = Hx - C[0], ry = Hy - C[1], rz = Hz - C[2];
              const cu = rx*u[0] + ry*u[1] + rz*u[2];
              const cv = rx*v[0] + ry*v[1] + rz*v[2];
              if (abs(cu) > hw || abs(cv) > hh) continue;
              const nearEdge = (Math.abs(abs(cu) - hw) < (hw * 0.02)) || (Math.abs(abs(cv) - hh) < (hh * 0.02));
              if (!nearEdge) continue;
              const di = (y * W + x) * 4;
              const col = FRAME.border; // rgba(...)
              // parse rgba quickly:
              const m = /rgba\((\d+),\s*(\d+),\s*(\d+),\s*([0-9.]+)\)/.exec(col);
              const rr = m?parseInt(m[1],10):255, gg=m?parseInt(m[2],10):255, bb=m?parseInt(m[3],10):255, aa=m?Math.round(parseFloat(m[4])*255):220;
              blend(D, di, rr, gg, bb, aa);
            }
          }
        }
      }

      ctx.putImageData(dest, 0, 0);
      // Create a blob URL for pannellum
      const blob = await new Promise(res => cvs.toBlob(res, "image/png", 0.95));
      return { url: URL.createObjectURL(blob), items };
    }

    function startViewer(panoUrl, items){
      const viewer = pannellum.viewer('viewer', {
        type: 'equirectangular',
        panorama: panoUrl,
        autoLoad: true,
        showControls: true,
        yaw: 0, pitch: 0, hfov: 85, minHfov: 40, maxHfov: 110,
        backgroundColor: [11,13,16]
      });

      viewer.on('load', () => {
        // add transparent clickable areas at the same yaw/pitch
        items.forEach((a, i) => {
          viewer.addHotSpot({
            yaw: a.yaw,
            pitch: a.pitch,
            scale: true,
            createTooltipFunc: (div, args) => {
              div.className = 'hotspot-hit';
              div.style.width  = args.w + 'px';
              div.style.height = args.h + 'px';
              div.setAttribute('aria-label', 'Artwork '+args.number);
              div.tabIndex = 0;
              div.addEventListener('click', () => openCard(args));
              div.addEventListener('keydown', e => {
                if(e.key==='Enter' || e.key===' '){ e.preventDefault(); openCard(args); }
              });
            },
            createTooltipArgs: {
              number: a.number,
              title:  "",
              imageUrl: a.url,
              w: a.wPx, h: a.hPx
            }
          });
        });
        toast('Gallery loaded');
      });

      viewer.on('error', e => { console.error(e); toast('Pannellum error'); });

      function openCard(a){
        // Replace with your nicer card UI if you want
        alert('Artwork #' + a.number);
      }
    }

    (async function main(){
      try{
        toast('Baking artworks onto walls…');
        const { url, items } = await bakeComposite();
        toast('Starting viewer…');
        startViewer(url, items);
      }catch(e){
        console.error(e);
        toast('Failed to bake or load. Is repo public and folders correct?');
      }
    })();
  </script>
</body>
</html>
